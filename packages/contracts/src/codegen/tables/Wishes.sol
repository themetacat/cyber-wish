// SPDX-License-Identifier: MIT
pragma solidity >=0.8.24;

/* Autogenerated file. Do not edit manually. */

// Import store internals
import { IStore } from "@latticexyz/store/src/IStore.sol";
import { StoreSwitch } from "@latticexyz/store/src/StoreSwitch.sol";
import { StoreCore } from "@latticexyz/store/src/StoreCore.sol";
import { Bytes } from "@latticexyz/store/src/Bytes.sol";
import { Memory } from "@latticexyz/store/src/Memory.sol";
import { SliceLib } from "@latticexyz/store/src/Slice.sol";
import { EncodeArray } from "@latticexyz/store/src/tightcoder/EncodeArray.sol";
import { FieldLayout } from "@latticexyz/store/src/FieldLayout.sol";
import { Schema } from "@latticexyz/store/src/Schema.sol";
import { EncodedLengths, EncodedLengthsLib } from "@latticexyz/store/src/EncodedLengths.sol";
import { ResourceId } from "@latticexyz/store/src/ResourceId.sol";

struct WishesData {
  address wisher;
  uint256 cycle;
  uint256 wishTime;
  uint256 incenseExpireTime;
  uint256 incenseId;
  uint256 blindBoxId;
  uint256 pointsIncense;
  uint256 pointsBlindBox;
  uint256 pointsIncenseEasterEgg;
  uint256 pointsBlindBoxEasterEgg;
  uint256 propId;
  bool isStar;
  string wishContent;
}

library Wishes {
  // Hex below is the result of `WorldResourceIdLib.encode({ namespace: "cyberwish", name: "Wishes", typeId: RESOURCE_OFFCHAIN_TABLE });`
  ResourceId constant _tableId = ResourceId.wrap(0x6f74637962657277697368000000000057697368657300000000000000000000);

  FieldLayout constant _fieldLayout =
    FieldLayout.wrap(0x01550c0114202020202020202020200100000000000000000000000000000000);

  // Hex-encoded key schema of (bytes32, bytes32)
  Schema constant _keySchema = Schema.wrap(0x004002005f5f0000000000000000000000000000000000000000000000000000);
  // Hex-encoded value schema of (address, uint256, uint256, uint256, uint256, uint256, uint256, uint256, uint256, uint256, uint256, bool, string)
  Schema constant _valueSchema = Schema.wrap(0x01550c01611f1f1f1f1f1f1f1f1f1f60c5000000000000000000000000000000);

  /**
   * @notice Get the table's key field names.
   * @return keyNames An array of strings with the names of key fields.
   */
  function getKeyNames() internal pure returns (string[] memory keyNames) {
    keyNames = new string[](2);
    keyNames[0] = "poolId";
    keyNames[1] = "id";
  }

  /**
   * @notice Get the table's value field names.
   * @return fieldNames An array of strings with the names of value fields.
   */
  function getFieldNames() internal pure returns (string[] memory fieldNames) {
    fieldNames = new string[](13);
    fieldNames[0] = "wisher";
    fieldNames[1] = "cycle";
    fieldNames[2] = "wishTime";
    fieldNames[3] = "incenseExpireTime";
    fieldNames[4] = "incenseId";
    fieldNames[5] = "blindBoxId";
    fieldNames[6] = "pointsIncense";
    fieldNames[7] = "pointsBlindBox";
    fieldNames[8] = "pointsIncenseEasterEgg";
    fieldNames[9] = "pointsBlindBoxEasterEgg";
    fieldNames[10] = "propId";
    fieldNames[11] = "isStar";
    fieldNames[12] = "wishContent";
  }

  /**
   * @notice Register the table with its config.
   */
  function register() internal {
    StoreSwitch.registerTable(_tableId, _fieldLayout, _keySchema, _valueSchema, getKeyNames(), getFieldNames());
  }

  /**
   * @notice Register the table with its config.
   */
  function _register() internal {
    StoreCore.registerTable(_tableId, _fieldLayout, _keySchema, _valueSchema, getKeyNames(), getFieldNames());
  }

  /**
   * @notice Set wisher.
   */
  function setWisher(bytes32 poolId, bytes32 id, address wisher) internal {
    bytes32[] memory _keyTuple = new bytes32[](2);
    _keyTuple[0] = poolId;
    _keyTuple[1] = id;

    StoreSwitch.setStaticField(_tableId, _keyTuple, 0, abi.encodePacked((wisher)), _fieldLayout);
  }

  /**
   * @notice Set wisher.
   */
  function _setWisher(bytes32 poolId, bytes32 id, address wisher) internal {
    bytes32[] memory _keyTuple = new bytes32[](2);
    _keyTuple[0] = poolId;
    _keyTuple[1] = id;

    StoreCore.setStaticField(_tableId, _keyTuple, 0, abi.encodePacked((wisher)), _fieldLayout);
  }

  /**
   * @notice Set cycle.
   */
  function setCycle(bytes32 poolId, bytes32 id, uint256 cycle) internal {
    bytes32[] memory _keyTuple = new bytes32[](2);
    _keyTuple[0] = poolId;
    _keyTuple[1] = id;

    StoreSwitch.setStaticField(_tableId, _keyTuple, 1, abi.encodePacked((cycle)), _fieldLayout);
  }

  /**
   * @notice Set cycle.
   */
  function _setCycle(bytes32 poolId, bytes32 id, uint256 cycle) internal {
    bytes32[] memory _keyTuple = new bytes32[](2);
    _keyTuple[0] = poolId;
    _keyTuple[1] = id;

    StoreCore.setStaticField(_tableId, _keyTuple, 1, abi.encodePacked((cycle)), _fieldLayout);
  }

  /**
   * @notice Set wishTime.
   */
  function setWishTime(bytes32 poolId, bytes32 id, uint256 wishTime) internal {
    bytes32[] memory _keyTuple = new bytes32[](2);
    _keyTuple[0] = poolId;
    _keyTuple[1] = id;

    StoreSwitch.setStaticField(_tableId, _keyTuple, 2, abi.encodePacked((wishTime)), _fieldLayout);
  }

  /**
   * @notice Set wishTime.
   */
  function _setWishTime(bytes32 poolId, bytes32 id, uint256 wishTime) internal {
    bytes32[] memory _keyTuple = new bytes32[](2);
    _keyTuple[0] = poolId;
    _keyTuple[1] = id;

    StoreCore.setStaticField(_tableId, _keyTuple, 2, abi.encodePacked((wishTime)), _fieldLayout);
  }

  /**
   * @notice Set incenseExpireTime.
   */
  function setIncenseExpireTime(bytes32 poolId, bytes32 id, uint256 incenseExpireTime) internal {
    bytes32[] memory _keyTuple = new bytes32[](2);
    _keyTuple[0] = poolId;
    _keyTuple[1] = id;

    StoreSwitch.setStaticField(_tableId, _keyTuple, 3, abi.encodePacked((incenseExpireTime)), _fieldLayout);
  }

  /**
   * @notice Set incenseExpireTime.
   */
  function _setIncenseExpireTime(bytes32 poolId, bytes32 id, uint256 incenseExpireTime) internal {
    bytes32[] memory _keyTuple = new bytes32[](2);
    _keyTuple[0] = poolId;
    _keyTuple[1] = id;

    StoreCore.setStaticField(_tableId, _keyTuple, 3, abi.encodePacked((incenseExpireTime)), _fieldLayout);
  }

  /**
   * @notice Set incenseId.
   */
  function setIncenseId(bytes32 poolId, bytes32 id, uint256 incenseId) internal {
    bytes32[] memory _keyTuple = new bytes32[](2);
    _keyTuple[0] = poolId;
    _keyTuple[1] = id;

    StoreSwitch.setStaticField(_tableId, _keyTuple, 4, abi.encodePacked((incenseId)), _fieldLayout);
  }

  /**
   * @notice Set incenseId.
   */
  function _setIncenseId(bytes32 poolId, bytes32 id, uint256 incenseId) internal {
    bytes32[] memory _keyTuple = new bytes32[](2);
    _keyTuple[0] = poolId;
    _keyTuple[1] = id;

    StoreCore.setStaticField(_tableId, _keyTuple, 4, abi.encodePacked((incenseId)), _fieldLayout);
  }

  /**
   * @notice Set blindBoxId.
   */
  function setBlindBoxId(bytes32 poolId, bytes32 id, uint256 blindBoxId) internal {
    bytes32[] memory _keyTuple = new bytes32[](2);
    _keyTuple[0] = poolId;
    _keyTuple[1] = id;

    StoreSwitch.setStaticField(_tableId, _keyTuple, 5, abi.encodePacked((blindBoxId)), _fieldLayout);
  }

  /**
   * @notice Set blindBoxId.
   */
  function _setBlindBoxId(bytes32 poolId, bytes32 id, uint256 blindBoxId) internal {
    bytes32[] memory _keyTuple = new bytes32[](2);
    _keyTuple[0] = poolId;
    _keyTuple[1] = id;

    StoreCore.setStaticField(_tableId, _keyTuple, 5, abi.encodePacked((blindBoxId)), _fieldLayout);
  }

  /**
   * @notice Set pointsIncense.
   */
  function setPointsIncense(bytes32 poolId, bytes32 id, uint256 pointsIncense) internal {
    bytes32[] memory _keyTuple = new bytes32[](2);
    _keyTuple[0] = poolId;
    _keyTuple[1] = id;

    StoreSwitch.setStaticField(_tableId, _keyTuple, 6, abi.encodePacked((pointsIncense)), _fieldLayout);
  }

  /**
   * @notice Set pointsIncense.
   */
  function _setPointsIncense(bytes32 poolId, bytes32 id, uint256 pointsIncense) internal {
    bytes32[] memory _keyTuple = new bytes32[](2);
    _keyTuple[0] = poolId;
    _keyTuple[1] = id;

    StoreCore.setStaticField(_tableId, _keyTuple, 6, abi.encodePacked((pointsIncense)), _fieldLayout);
  }

  /**
   * @notice Set pointsBlindBox.
   */
  function setPointsBlindBox(bytes32 poolId, bytes32 id, uint256 pointsBlindBox) internal {
    bytes32[] memory _keyTuple = new bytes32[](2);
    _keyTuple[0] = poolId;
    _keyTuple[1] = id;

    StoreSwitch.setStaticField(_tableId, _keyTuple, 7, abi.encodePacked((pointsBlindBox)), _fieldLayout);
  }

  /**
   * @notice Set pointsBlindBox.
   */
  function _setPointsBlindBox(bytes32 poolId, bytes32 id, uint256 pointsBlindBox) internal {
    bytes32[] memory _keyTuple = new bytes32[](2);
    _keyTuple[0] = poolId;
    _keyTuple[1] = id;

    StoreCore.setStaticField(_tableId, _keyTuple, 7, abi.encodePacked((pointsBlindBox)), _fieldLayout);
  }

  /**
   * @notice Set pointsIncenseEasterEgg.
   */
  function setPointsIncenseEasterEgg(bytes32 poolId, bytes32 id, uint256 pointsIncenseEasterEgg) internal {
    bytes32[] memory _keyTuple = new bytes32[](2);
    _keyTuple[0] = poolId;
    _keyTuple[1] = id;

    StoreSwitch.setStaticField(_tableId, _keyTuple, 8, abi.encodePacked((pointsIncenseEasterEgg)), _fieldLayout);
  }

  /**
   * @notice Set pointsIncenseEasterEgg.
   */
  function _setPointsIncenseEasterEgg(bytes32 poolId, bytes32 id, uint256 pointsIncenseEasterEgg) internal {
    bytes32[] memory _keyTuple = new bytes32[](2);
    _keyTuple[0] = poolId;
    _keyTuple[1] = id;

    StoreCore.setStaticField(_tableId, _keyTuple, 8, abi.encodePacked((pointsIncenseEasterEgg)), _fieldLayout);
  }

  /**
   * @notice Set pointsBlindBoxEasterEgg.
   */
  function setPointsBlindBoxEasterEgg(bytes32 poolId, bytes32 id, uint256 pointsBlindBoxEasterEgg) internal {
    bytes32[] memory _keyTuple = new bytes32[](2);
    _keyTuple[0] = poolId;
    _keyTuple[1] = id;

    StoreSwitch.setStaticField(_tableId, _keyTuple, 9, abi.encodePacked((pointsBlindBoxEasterEgg)), _fieldLayout);
  }

  /**
   * @notice Set pointsBlindBoxEasterEgg.
   */
  function _setPointsBlindBoxEasterEgg(bytes32 poolId, bytes32 id, uint256 pointsBlindBoxEasterEgg) internal {
    bytes32[] memory _keyTuple = new bytes32[](2);
    _keyTuple[0] = poolId;
    _keyTuple[1] = id;

    StoreCore.setStaticField(_tableId, _keyTuple, 9, abi.encodePacked((pointsBlindBoxEasterEgg)), _fieldLayout);
  }

  /**
   * @notice Set propId.
   */
  function setPropId(bytes32 poolId, bytes32 id, uint256 propId) internal {
    bytes32[] memory _keyTuple = new bytes32[](2);
    _keyTuple[0] = poolId;
    _keyTuple[1] = id;

    StoreSwitch.setStaticField(_tableId, _keyTuple, 10, abi.encodePacked((propId)), _fieldLayout);
  }

  /**
   * @notice Set propId.
   */
  function _setPropId(bytes32 poolId, bytes32 id, uint256 propId) internal {
    bytes32[] memory _keyTuple = new bytes32[](2);
    _keyTuple[0] = poolId;
    _keyTuple[1] = id;

    StoreCore.setStaticField(_tableId, _keyTuple, 10, abi.encodePacked((propId)), _fieldLayout);
  }

  /**
   * @notice Set isStar.
   */
  function setIsStar(bytes32 poolId, bytes32 id, bool isStar) internal {
    bytes32[] memory _keyTuple = new bytes32[](2);
    _keyTuple[0] = poolId;
    _keyTuple[1] = id;

    StoreSwitch.setStaticField(_tableId, _keyTuple, 11, abi.encodePacked((isStar)), _fieldLayout);
  }

  /**
   * @notice Set isStar.
   */
  function _setIsStar(bytes32 poolId, bytes32 id, bool isStar) internal {
    bytes32[] memory _keyTuple = new bytes32[](2);
    _keyTuple[0] = poolId;
    _keyTuple[1] = id;

    StoreCore.setStaticField(_tableId, _keyTuple, 11, abi.encodePacked((isStar)), _fieldLayout);
  }

  /**
   * @notice Set the full data using individual values.
   */
  function set(
    bytes32 poolId,
    bytes32 id,
    address wisher,
    uint256 cycle,
    uint256 wishTime,
    uint256 incenseExpireTime,
    uint256 incenseId,
    uint256 blindBoxId,
    uint256 pointsIncense,
    uint256 pointsBlindBox,
    uint256 pointsIncenseEasterEgg,
    uint256 pointsBlindBoxEasterEgg,
    uint256 propId,
    bool isStar,
    string memory wishContent
  ) internal {
    bytes memory _staticData = encodeStatic(
      wisher,
      cycle,
      wishTime,
      incenseExpireTime,
      incenseId,
      blindBoxId,
      pointsIncense,
      pointsBlindBox,
      pointsIncenseEasterEgg,
      pointsBlindBoxEasterEgg,
      propId,
      isStar
    );

    EncodedLengths _encodedLengths = encodeLengths(wishContent);
    bytes memory _dynamicData = encodeDynamic(wishContent);

    bytes32[] memory _keyTuple = new bytes32[](2);
    _keyTuple[0] = poolId;
    _keyTuple[1] = id;

    StoreSwitch.setRecord(_tableId, _keyTuple, _staticData, _encodedLengths, _dynamicData);
  }

  /**
   * @notice Set the full data using individual values.
   */
  function _set(
    bytes32 poolId,
    bytes32 id,
    address wisher,
    uint256 cycle,
    uint256 wishTime,
    uint256 incenseExpireTime,
    uint256 incenseId,
    uint256 blindBoxId,
    uint256 pointsIncense,
    uint256 pointsBlindBox,
    uint256 pointsIncenseEasterEgg,
    uint256 pointsBlindBoxEasterEgg,
    uint256 propId,
    bool isStar,
    string memory wishContent
  ) internal {
    bytes memory _staticData = encodeStatic(
      wisher,
      cycle,
      wishTime,
      incenseExpireTime,
      incenseId,
      blindBoxId,
      pointsIncense,
      pointsBlindBox,
      pointsIncenseEasterEgg,
      pointsBlindBoxEasterEgg,
      propId,
      isStar
    );

    EncodedLengths _encodedLengths = encodeLengths(wishContent);
    bytes memory _dynamicData = encodeDynamic(wishContent);

    bytes32[] memory _keyTuple = new bytes32[](2);
    _keyTuple[0] = poolId;
    _keyTuple[1] = id;

    StoreCore.setRecord(_tableId, _keyTuple, _staticData, _encodedLengths, _dynamicData, _fieldLayout);
  }

  /**
   * @notice Set the full data using the data struct.
   */
  function set(bytes32 poolId, bytes32 id, WishesData memory _table) internal {
    bytes memory _staticData = encodeStatic(
      _table.wisher,
      _table.cycle,
      _table.wishTime,
      _table.incenseExpireTime,
      _table.incenseId,
      _table.blindBoxId,
      _table.pointsIncense,
      _table.pointsBlindBox,
      _table.pointsIncenseEasterEgg,
      _table.pointsBlindBoxEasterEgg,
      _table.propId,
      _table.isStar
    );

    EncodedLengths _encodedLengths = encodeLengths(_table.wishContent);
    bytes memory _dynamicData = encodeDynamic(_table.wishContent);

    bytes32[] memory _keyTuple = new bytes32[](2);
    _keyTuple[0] = poolId;
    _keyTuple[1] = id;

    StoreSwitch.setRecord(_tableId, _keyTuple, _staticData, _encodedLengths, _dynamicData);
  }

  /**
   * @notice Set the full data using the data struct.
   */
  function _set(bytes32 poolId, bytes32 id, WishesData memory _table) internal {
    bytes memory _staticData = encodeStatic(
      _table.wisher,
      _table.cycle,
      _table.wishTime,
      _table.incenseExpireTime,
      _table.incenseId,
      _table.blindBoxId,
      _table.pointsIncense,
      _table.pointsBlindBox,
      _table.pointsIncenseEasterEgg,
      _table.pointsBlindBoxEasterEgg,
      _table.propId,
      _table.isStar
    );

    EncodedLengths _encodedLengths = encodeLengths(_table.wishContent);
    bytes memory _dynamicData = encodeDynamic(_table.wishContent);

    bytes32[] memory _keyTuple = new bytes32[](2);
    _keyTuple[0] = poolId;
    _keyTuple[1] = id;

    StoreCore.setRecord(_tableId, _keyTuple, _staticData, _encodedLengths, _dynamicData, _fieldLayout);
  }

  /**
   * @notice Decode the tightly packed blob of static data using this table's field layout.
   */
  function decodeStatic(
    bytes memory _blob
  )
    internal
    pure
    returns (
      address wisher,
      uint256 cycle,
      uint256 wishTime,
      uint256 incenseExpireTime,
      uint256 incenseId,
      uint256 blindBoxId,
      uint256 pointsIncense,
      uint256 pointsBlindBox,
      uint256 pointsIncenseEasterEgg,
      uint256 pointsBlindBoxEasterEgg,
      uint256 propId,
      bool isStar
    )
  {
    wisher = (address(Bytes.getBytes20(_blob, 0)));

    cycle = (uint256(Bytes.getBytes32(_blob, 20)));

    wishTime = (uint256(Bytes.getBytes32(_blob, 52)));

    incenseExpireTime = (uint256(Bytes.getBytes32(_blob, 84)));

    incenseId = (uint256(Bytes.getBytes32(_blob, 116)));

    blindBoxId = (uint256(Bytes.getBytes32(_blob, 148)));

    pointsIncense = (uint256(Bytes.getBytes32(_blob, 180)));

    pointsBlindBox = (uint256(Bytes.getBytes32(_blob, 212)));

    pointsIncenseEasterEgg = (uint256(Bytes.getBytes32(_blob, 244)));

    pointsBlindBoxEasterEgg = (uint256(Bytes.getBytes32(_blob, 276)));

    propId = (uint256(Bytes.getBytes32(_blob, 308)));

    isStar = (_toBool(uint8(Bytes.getBytes1(_blob, 340))));
  }

  /**
   * @notice Decode the tightly packed blob of dynamic data using the encoded lengths.
   */
  function decodeDynamic(
    EncodedLengths _encodedLengths,
    bytes memory _blob
  ) internal pure returns (string memory wishContent) {
    uint256 _start;
    uint256 _end;
    unchecked {
      _end = _encodedLengths.atIndex(0);
    }
    wishContent = (string(SliceLib.getSubslice(_blob, _start, _end).toBytes()));
  }

  /**
   * @notice Decode the tightly packed blobs using this table's field layout.
   * @param _staticData Tightly packed static fields.
   * @param _encodedLengths Encoded lengths of dynamic fields.
   * @param _dynamicData Tightly packed dynamic fields.
   */
  function decode(
    bytes memory _staticData,
    EncodedLengths _encodedLengths,
    bytes memory _dynamicData
  ) internal pure returns (WishesData memory _table) {
    (
      _table.wisher,
      _table.cycle,
      _table.wishTime,
      _table.incenseExpireTime,
      _table.incenseId,
      _table.blindBoxId,
      _table.pointsIncense,
      _table.pointsBlindBox,
      _table.pointsIncenseEasterEgg,
      _table.pointsBlindBoxEasterEgg,
      _table.propId,
      _table.isStar
    ) = decodeStatic(_staticData);

    (_table.wishContent) = decodeDynamic(_encodedLengths, _dynamicData);
  }

  /**
   * @notice Delete all data for given keys.
   */
  function deleteRecord(bytes32 poolId, bytes32 id) internal {
    bytes32[] memory _keyTuple = new bytes32[](2);
    _keyTuple[0] = poolId;
    _keyTuple[1] = id;

    StoreSwitch.deleteRecord(_tableId, _keyTuple);
  }

  /**
   * @notice Delete all data for given keys.
   */
  function _deleteRecord(bytes32 poolId, bytes32 id) internal {
    bytes32[] memory _keyTuple = new bytes32[](2);
    _keyTuple[0] = poolId;
    _keyTuple[1] = id;

    StoreCore.deleteRecord(_tableId, _keyTuple, _fieldLayout);
  }

  /**
   * @notice Tightly pack static (fixed length) data using this table's schema.
   * @return The static data, encoded into a sequence of bytes.
   */
  function encodeStatic(
    address wisher,
    uint256 cycle,
    uint256 wishTime,
    uint256 incenseExpireTime,
    uint256 incenseId,
    uint256 blindBoxId,
    uint256 pointsIncense,
    uint256 pointsBlindBox,
    uint256 pointsIncenseEasterEgg,
    uint256 pointsBlindBoxEasterEgg,
    uint256 propId,
    bool isStar
  ) internal pure returns (bytes memory) {
    return
      abi.encodePacked(
        wisher,
        cycle,
        wishTime,
        incenseExpireTime,
        incenseId,
        blindBoxId,
        pointsIncense,
        pointsBlindBox,
        pointsIncenseEasterEgg,
        pointsBlindBoxEasterEgg,
        propId,
        isStar
      );
  }

  /**
   * @notice Tightly pack dynamic data lengths using this table's schema.
   * @return _encodedLengths The lengths of the dynamic fields (packed into a single bytes32 value).
   */
  function encodeLengths(string memory wishContent) internal pure returns (EncodedLengths _encodedLengths) {
    // Lengths are effectively checked during copy by 2**40 bytes exceeding gas limits
    unchecked {
      _encodedLengths = EncodedLengthsLib.pack(bytes(wishContent).length);
    }
  }

  /**
   * @notice Tightly pack dynamic (variable length) data using this table's schema.
   * @return The dynamic data, encoded into a sequence of bytes.
   */
  function encodeDynamic(string memory wishContent) internal pure returns (bytes memory) {
    return abi.encodePacked(bytes((wishContent)));
  }

  /**
   * @notice Encode all of a record's fields.
   * @return The static (fixed length) data, encoded into a sequence of bytes.
   * @return The lengths of the dynamic fields (packed into a single bytes32 value).
   * @return The dynamic (variable length) data, encoded into a sequence of bytes.
   */
  function encode(
    address wisher,
    uint256 cycle,
    uint256 wishTime,
    uint256 incenseExpireTime,
    uint256 incenseId,
    uint256 blindBoxId,
    uint256 pointsIncense,
    uint256 pointsBlindBox,
    uint256 pointsIncenseEasterEgg,
    uint256 pointsBlindBoxEasterEgg,
    uint256 propId,
    bool isStar,
    string memory wishContent
  ) internal pure returns (bytes memory, EncodedLengths, bytes memory) {
    bytes memory _staticData = encodeStatic(
      wisher,
      cycle,
      wishTime,
      incenseExpireTime,
      incenseId,
      blindBoxId,
      pointsIncense,
      pointsBlindBox,
      pointsIncenseEasterEgg,
      pointsBlindBoxEasterEgg,
      propId,
      isStar
    );

    EncodedLengths _encodedLengths = encodeLengths(wishContent);
    bytes memory _dynamicData = encodeDynamic(wishContent);

    return (_staticData, _encodedLengths, _dynamicData);
  }

  /**
   * @notice Encode keys as a bytes32 array using this table's field layout.
   */
  function encodeKeyTuple(bytes32 poolId, bytes32 id) internal pure returns (bytes32[] memory) {
    bytes32[] memory _keyTuple = new bytes32[](2);
    _keyTuple[0] = poolId;
    _keyTuple[1] = id;

    return _keyTuple;
  }
}

/**
 * @notice Cast a value to a bool.
 * @dev Boolean values are encoded as uint8 (1 = true, 0 = false), but Solidity doesn't allow casting between uint8 and bool.
 * @param value The uint8 value to convert.
 * @return result The boolean value.
 */
function _toBool(uint8 value) pure returns (bool result) {
  assembly {
    result := value
  }
}
